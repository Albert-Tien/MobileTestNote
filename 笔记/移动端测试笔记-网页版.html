<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>[toc]</title>
<style>
*{margin:0;padding:0}
body{
  min-width: 200px;
  max-width: 760px;
  margin: 0 auto;
  padding: 30px;

	font-family:"Nunito","HelveticaNeue-Light","Helvetica Neue Light","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:300;font-size:14px;background:#fff;color:#333}
.markdown-body{line-height:1.5em;font-size:1.3em}
h1{font-size:1.8em}
h2{font-size:1.5em}
h3{font-size:1.3em}
a{text-decoration:none;outline-width:0;color:#258fb8}
a:hover{color:#2571B8}

.markdown-body img.left,.markdown-body video.left{float:left;margin-right:1.5em}


.markdown-body img.right, .markdown-body video.right{float:right;margin-left:1.5em}

.markdown-body img.center,.markdown-body video.center{display:block;margin:0 auto 1.5em}

.markdown-body img.left, .markdown-body video.left, .markdown-body img.right, .markdown-body video.right{margin-bottom:.8em}

.alignleft{float:left}
.alignright{float:right}
.clearfix{*zoom:1}
.clearfix:after{content:"";display:table;clear:both}


.markdown-body h1{font-weight:300;line-height:35px;margin-bottom:20px}
.markdown-body h1 a{color:#666}
.markdown-body a:hover{text-decoration:underline}
.markdown-body .more-link{display:block;margin-top:16px;padding-left:30px;position:relative}
.markdown-body p,.markdown-body blockquote,.markdown-body ul,.markdown-body ol,.markdown-body dl,.markdown-body table,.markdown-body iframe,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body .video-container{margin-top:20px}
.markdown-body ul,.markdown-body ol,.markdown-body dl{margin-left:20px}
.markdown-body ul ul,.markdown-body ul ol,.markdown-body ul dl,.markdown-body ol ul,.markdown-body ol ol,.markdown-body ol dl,.markdown-body dl ul,.markdown-body dl ol,.markdown-body dl dl{margin-top:0}
.markdown-body strong{font-weight:bold}
.markdown-body em{font-style:italic}
.markdown-body p{margin-top:10px}
.markdown-body h2{font-weight:300;border-bottom:1px solid #ddd;position:relative}
.markdown-body h2:before{content:"";position:absolute;bottom:-2px;border-bottom:1px solid #fff;width:100%}
.markdown-body img,.markdown-body video{max-width:100%;height:auto}
.markdown-body blockquote{background:#ddd;border-left:5px solid #ccc;padding:15px 20px;margin-top:10px}
.markdown-body blockquote>p:first-of-type{margin-top:0}
.markdown-body iframe{border:none}
.markdown-body table{background:#ddd;border:1px solid #ccc;border-spacing:0;margin-top:10px}
.markdown-body table th{background:#ccc;padding:0 15px}
.markdown-body table td{text-align:center}
.markdown-body table tr:nth-of-type(2n){background:#d5d5d5}
.markdown-body .caption{display:block;font-size:0.9em;color:#999;padding-left:25px;position:relative}
.markdown-body .caption:before{content:"\f040";color:#ccc;font:1.3em FontAwesome;line-height:1.6em;position:absolute;left:0}
.markdown-body .video-container{position:relative;padding-bottom:56.25%;padding-top:30px;height:0;overflow:hidden}
.markdown-body .video-container iframe,.markdown-body .video-container object,.markdown-body .video-container embed{position:absolute;top:0;left:0;width:100%;height:100%;margin-top:0}

.markdown-body footer{padding:15px 0;border-top:1px solid #fff;text-align:center;font-size:0.9em}
code,pre{background:#ddd;border:1px solid #ccc;font-family:Menlo,Monaco,"Andale Mono","lucida console","Courier New",monospace; font-size: 0.9em;}
code{font-size:0.9em;padding:1px 3px;margin:0 3px}
pre code{background:none;border:none;padding:0;margin:0}


.markdown-body p{margin-top:10px}
.markdown-body h2{font-size:1.3em;color:#333;margin-top:30px;font-weight:bold}
.markdown-body h2::before{border-bottom:none}
.markdown-body blockquote{border-left:5px solid #2571B8;background:#F7F7F7}
.markdown-body blockquote p{margin-top:0px}
.markdown-body table{line-height:1.2em}
.markdown-body table td{text-align:left}


.markdown-body pre{ background: none; border: none; padding: 0; margin: 4px 0px;}
.markdown-body{text-align: left;}
.markdown-body table th,.markdown-body table td{ padding: 4px;border-collapse: collapse; border:solid 1px #ddd;}

.markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6{ line-height: 1.2em;}
	
.markdown-body{border: none;}
.markdown-body	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}

/*

Orginal Style from ethanschoonover.com/solarized (c) Jeremy Hull <sourdrums@gmail.com>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #002b36;
  color: #839496;
  -webkit-text-size-adjust: none;
}

.hljs-comment,
.diff .hljs-header,
.hljs-doctype,
.hljs-pi,
.lisp .hljs-string {
  color: #586e75;
}

/* Solarized Green */
.hljs-keyword,
.hljs-winutils,
.method,
.hljs-addition,
.css .hljs-tag,
.hljs-request,
.hljs-status,
.nginx .hljs-title {
  color: #859900;
}

/* Solarized Cyan */
.hljs-number,
.hljs-command,
.hljs-string,
.hljs-tag .hljs-value,
.hljs-rule .hljs-value,
.hljs-doctag,
.tex .hljs-formula,
.hljs-regexp,
.hljs-hexcolor,
.hljs-link_url {
  color: #2aa198;
}

/* Solarized Blue */
.hljs-title,
.hljs-localvars,
.hljs-chunk,
.hljs-decorator,
.hljs-built_in,
.hljs-identifier,
.vhdl .hljs-literal,
.hljs-id,
.css .hljs-function,
.hljs-name {
  color: #268bd2;
}

/* Solarized Yellow */
.hljs-attribute,
.hljs-variable,
.lisp .hljs-body,
.smalltalk .hljs-number,
.hljs-constant,
.hljs-class .hljs-title,
.hljs-parent,
.hljs-type,
.hljs-link_reference {
  color: #b58900;
}

/* Solarized Orange */
.hljs-preprocessor,
.hljs-preprocessor .hljs-keyword,
.hljs-pragma,
.hljs-shebang,
.hljs-symbol,
.hljs-symbol .hljs-string,
.diff .hljs-change,
.hljs-special,
.hljs-attr_selector,
.hljs-subst,
.hljs-cdata,
.css .hljs-pseudo,
.hljs-header {
  color: #cb4b16;
}

/* Solarized Red */
.hljs-deletion,
.hljs-important {
  color: #dc322f;
}

/* Solarized Violet */
.hljs-link_label {
  color: #6c71c4;
}

.tex .hljs-formula {
  background: #073642;
}


</style>

<style> @media print{ .hljs{overflow: visible; word-wrap: break-word !important;} }</style></head><body><div class="markdown-body">
<ul>
<li>
<a href="#toc_0">01.移动端测试知识概览</a>
<ul>
<li>
<a href="#toc_1">01.1 移动端测试是什么？</a>
</li>
<li>
<a href="#toc_2">01.2 移动端测试分类？</a>
</li>
<li>
<a href="#toc_3">01.3 市场招聘如何？</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">02.移动端测试环境搭建</a>
<ul>
<li>
<a href="#toc_5">02.1 Java环境</a>
<ul>
<li>
<a href="#toc_6">windows</a>
</li>
<li>
<a href="#toc_7">macOS</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">02.2 AndroidSDK环境</a>
<ul>
<li>
<a href="#toc_9">windows</a>
</li>
<li>
<a href="#toc_10">macOS</a>
</li>
<li>
<a href="#toc_11">可能出现的问题</a>
</li>
<li>
<a href="#toc_12">补充：下载其他版本SDK</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">02.3 Android模拟器安装</a>
<ul>
<li>
<a href="#toc_14">windows</a>
</li>
<li>
<a href="#toc_15">macOS</a>
</li>
<li>
<a href="#toc_16">可能出现的问题</a>
</li>
<li>
<a href="#toc_17">为虚拟机提供安装apk功能</a>
</li>
<li>
<a href="#toc_18">补充：下载其他版本模拟器</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_19">03.包名和启动名</a>
<ul>
<li>
<a href="#toc_20">03.1 包名</a>
</li>
<li>
<a href="#toc_21">03.2 启动名</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">04.adb命令介绍</a>
<ul>
<li>
<a href="#toc_23">04.1 adb的含义</a>
</li>
<li>
<a href="#toc_24">04.2 adb常用命令</a>
<ul>
<li>
<a href="#toc_25">adb帮助</a>
</li>
<li>
<a href="#toc_26">启动adb server</a>
</li>
<li>
<a href="#toc_27">关闭adb server</a>
</li>
<li>
<a href="#toc_28">获取设备号</a>
</li>
<li>
<a href="#toc_29">获取系统版本</a>
</li>
<li>
<a href="#toc_30">发送文件到手机</a>
</li>
<li>
<a href="#toc_31">从手机拉取文件</a>
</li>
<li>
<a href="#toc_32">查看手机运行日志</a>
</li>
<li>
<a href="#toc_33">手机shell命令行</a>
</li>
<li>
<a href="#toc_34">获取app包名和启动名</a>
</li>
<li>
<a href="#toc_35">安装app到手机</a>
</li>
<li>
<a href="#toc_36">卸载手机手机app</a>
</li>
<li>
<a href="#toc_37">获取app启动时间</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_38">05.移动端自动化测试工具</a>
<ul>
<li>
<a href="#toc_39">05.1 主流的移动端自动化工具</a>
</li>
<li>
<a href="#toc_40">05.2 Appium介绍</a>
</li>
<li>
<a href="#toc_41">05.3 Appium特点</a>
</li>
<li>
<a href="#toc_42">05.4 Appium自动化测试环境搭建</a>
<ul>
<li>
<a href="#toc_43">Appium客户端安装</a>
<ul>
<li>
<a href="#toc_44">Appium背景介绍</a>
</li>
<li>
<a href="#toc_45">Appium桌面客户端安装方式</a>
</li>
<li>
<a href="#toc_46">Appium命令行安装方式</a>
</li>
</ul>
</li>
<li>
<a href="#toc_47">Appium-python库安装</a>
<ul>
<li>
<a href="#toc_48">命令行安装(需要联网)</a>
</li>
<li>
<a href="#toc_49">安装包安装</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_50">06.Hello Appium</a>
<ul>
<li>
<a href="#toc_51">需求</a>
</li>
<li>
<a href="#toc_52">思路</a>
</li>
<li>
<a href="#toc_53">方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_54">07.Appium 基础API</a>
<ul>
<li>
<a href="#toc_55">App基础操作API</a>
<ul>
<li>
<a href="#toc_56">前置代码</a>
</li>
<li>
<a href="#toc_57">获取app包名和启动名</a>
</li>
<li>
<a href="#toc_58">脚本内启动其他app</a>
</li>
<li>
<a href="#toc_59">关闭app</a>
</li>
<li>
<a href="#toc_60">关闭驱动对象</a>
</li>
<li>
<a href="#toc_61">安装APK到手机</a>
</li>
<li>
<a href="#toc_62">手机中移除APP</a>
</li>
<li>
<a href="#toc_63">判断APP是否已安装</a>
</li>
<li>
<a href="#toc_64">发送文件到手机</a>
</li>
<li>
<a href="#toc_65">从手机中拉取文件</a>
</li>
<li>
<a href="#toc_66">获取当前屏幕内元素结构</a>
</li>
<li>
<a href="#toc_67">应用置于后台事件</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_68">08.UIAutomatorViewer</a>
<ul>
<li>
<a href="#toc_69">工具简介</a>
</li>
<li>
<a href="#toc_70">如何使用</a>
</li>
</ul>
</li>
<li>
<a href="#toc_71">09.元素定位API</a>
<ul>
<li>
<a href="#toc_72">定位一个元素 element</a>
<ul>
<li>
<a href="#toc_73">通过id定位</a>
</li>
<li>
<a href="#toc_74">通过class定位</a>
</li>
<li>
<a href="#toc_75">通过xpath定位</a>
</li>
</ul>
</li>
<li>
<a href="#toc_76">定位一组元素 elements</a>
<ul>
<li>
<a href="#toc_77">通过id方式定位一组元素</a>
</li>
<li>
<a href="#toc_78">通过class方式定位一组元素</a>
</li>
<li>
<a href="#toc_79">通过xpath方式定位一组元素</a>
</li>
</ul>
</li>
<li>
<a href="#toc_80">WebDriverWait 显示等待</a>
</li>
</ul>
</li>
<li>
<a href="#toc_81">10.元素操作API</a>
<ul>
<li>
<a href="#toc_82">点击元素</a>
</li>
<li>
<a href="#toc_83">发送数据到输入框</a>
</li>
<li>
<a href="#toc_84">清空输入框内容</a>
</li>
<li>
<a href="#toc_85">获取元素的文本内容</a>
</li>
<li>
<a href="#toc_86">获取元素的属性值</a>
</li>
<li>
<a href="#toc_87">获取元素在屏幕上的坐标</a>
</li>
</ul>
</li>
<li>
<a href="#toc_88">11.滑动和拖拽事件</a>
<ul>
<li>
<a href="#toc_89">swipe 滑动事件</a>
</li>
<li>
<a href="#toc_90">scroll 滑动事件</a>
</li>
<li>
<a href="#toc_91">drag 拖拽事件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_92">12.高级手势TouchAction</a>
<ul>
<li>
<a href="#toc_93">手指轻敲操作</a>
</li>
<li>
<a href="#toc_94">手指按下和抬起操作</a>
</li>
<li>
<a href="#toc_95">等待操作</a>
</li>
<li>
<a href="#toc_96">手指长按操作</a>
</li>
<li>
<a href="#toc_97">手指移动操作</a>
</li>
<li>
<a href="#toc_98">案例-手势解锁</a>
</li>
</ul>
</li>
<li>
<a href="#toc_99">13.手机操作API</a>
<ul>
<li>
<a href="#toc_100">获取手机时间</a>
</li>
<li>
<a href="#toc_101">获取手机的宽高</a>
</li>
<li>
<a href="#toc_102">发送键到设备</a>
</li>
<li>
<a href="#toc_103">操作手机通知栏</a>
</li>
<li>
<a href="#toc_104">获取手机当前网络</a>
</li>
<li>
<a href="#toc_105">设置手机网络</a>
</li>
<li>
<a href="#toc_106">手机截图</a>
</li>
</ul>
</li>
<li>
<a href="#toc_107">14.Pytest安装和介绍</a>
<ul>
<li>
<a href="#toc_108">Pytest安装</a>
</li>
<li>
<a href="#toc_109">Pytest安装成功校验</a>
</li>
</ul>
</li>
<li>
<a href="#toc_110">15.Pytest基本使用</a>
<ul>
<li>
<a href="#toc_111">Hello Pytest</a>
</li>
<li>
<a href="#toc_112">Pytest运行方式</a>
</li>
</ul>
</li>
<li>
<a href="#toc_113">16.setup和teardown函数</a>
<ul>
<li>
<a href="#toc_114">类级别</a>
</li>
</ul>
</li>
<li>
<a href="#toc_115">17.Pytest配置文件</a>
<ul>
<li>
<a href="#toc_116">配置pytest命令行运行参数</a>
</li>
<li>
<a href="#toc_117">配置测试搜索的路径</a>
</li>
<li>
<a href="#toc_118">配置测试搜索的文件名</a>
</li>
<li>
<a href="#toc_119">配置测试搜索的测试类名</a>
</li>
<li>
<a href="#toc_120">配置测试搜索的测试函数名</a>
</li>
</ul>
</li>
<li>
<a href="#toc_121">18.Pytest常用插件</a>
<ul>
<li>
<a href="#toc_122">Pytest测试报告</a>
</li>
<li>
<a href="#toc_123">Pytest控制函数执行顺序</a>
</li>
<li>
<a href="#toc_124">Pytest失败重试</a>
</li>
</ul>
</li>
<li>
<a href="#toc_125">19.Pytest-fixture</a>
<ul>
<li>
<a href="#toc_126">fixture(通过参数引用)</a>
</li>
<li>
<a href="#toc_127">fixture(通过函数引用)</a>
</li>
<li>
<a href="#toc_128">fixture(默认设置为运行)</a>
</li>
<li>
<a href="#toc_129">fixture(作用域为function)</a>
</li>
<li>
<a href="#toc_130">fixture(作用域为class)</a>
</li>
<li>
<a href="#toc_131">fixture(返回值)</a>
</li>
</ul>
</li>
<li>
<a href="#toc_132">20.Pytest高阶用法</a>
<ul>
<li>
<a href="#toc_133">跳过测试函数</a>
</li>
<li>
<a href="#toc_134">标记为预期失败函数</a>
</li>
<li>
<a href="#toc_135">函数数据参数化</a>
</li>
</ul>
</li>
<li>
<a href="#toc_136">小作业</a>
<ul>
<li>
<a href="#toc_137">元素定位和操作练习</a>
</li>
<li>
<a href="#toc_138">滑动和拖拽时间练习</a>
</li>
</ul>
</li>
<li>
<a href="#toc_139">常用代码</a>
<ul>
<li>
<a href="#toc_140">前置代码</a>
</li>
<li>
<a href="#toc_141">获取包名</a>
</li>
<li>
<a href="#toc_142">xPath</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">01.移动端测试知识概览</h2>

<h3 id="toc_1">01.1 移动端测试是什么？</h3>

<p>移动端测试是指对移动应用进行的测试，即实体的特性满足需求的程度。</p>

<h3 id="toc_2">01.2 移动端测试分类？</h3>

<ul>
<li>app功能测试

<ul>
<li>业务逻辑正确性测试</li>
<li>文档</li>
<li>兼容性测试</li>
<li>系统版本</li>
<li>分辨率</li>
<li>网络情况</li>
<li>异常测试</li>
<li>热启动应用</li>
<li>网络切换&amp;中断恢复</li>
<li>电话&amp;信息中断恢复</li>
<li>升级&amp;安装卸载测试</li>
<li>健壮性测试</li>
<li>手机资源消耗</li>
<li>流量消耗</li>
<li>崩溃恢复等测试</li>
</ul></li>
<li>app自动化测试

<ul>
<li>通过场景和数据的预设，把以人为驱动的测试行为转化为机器执行的一种过程，并不是所有功能都能进行自动化。</li>
</ul></li>
<li>app安全测试

<ul>
<li>通过安全测试技术，保证app尽可能的不存在安全漏洞.</li>
</ul></li>
</ul>

<h3 id="toc_3">01.3 市场招聘如何？</h3>

<p>互联网移动场景下业务的爆发，导致移动端开发和测试人员需求量增大，市场很缺移动端的人才。</p>

<p>公司待遇：</p>

<ol>
<li>app功能测试，一般1-3年的功能测试人员月薪8k-15k</li>
<li>app自动化测试，一般1-3年的自动化测试月薪13k-25k</li>
</ol>

<h2 id="toc_4">02.移动端测试环境搭建</h2>

<p>我们的目标是Android测试，所以环境需要搭建三个，Java，AndroidSDK，Android模拟器。</p>

<p>为什么要安装这三个环境，我们倒着来说：</p>

<p>Android模拟器：实际上就是一台手机，方便我们给大家展示效果。</p>

<p>AndroidSDK：Android SDK给你提供开发测试所必须的Android API类库。</p>

<p>Java：Android的底层是c、c++，应用层用的语言是Java所以需要使用Java环境。</p>

<h3 id="toc_5">02.1 Java环境</h3>

<h4 id="toc_6">windows</h4>

<p>安装JDK1.8</p>

<pre><code>运行jdk-8u151-windows-x64.exe文件，默认安装即可(例如我的安装目录：C:\Program Files\Java\jdk1.8.0)
</code></pre>

<p>配置java环境变量(Windowns7为例)</p>

<pre><code>1.进入我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量

2.在系统变量下点击新建 -&gt; 变量名: JAVA_HOME -&gt; 变量值: C:\Program Files\Java\jdk1.8.0 -&gt; 点击确定按钮

3.在系统变量下点击新建 -&gt; 变量名: CLASSPATH -&gt; 变量值: .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar(***变量值最前面有一个&quot;.&quot;) -&gt; 点击确定按钮

4.在系统变量下找到系统的path变量，进入在最后添加：;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin(最前面是一个分号，如果path变量最后已有分号，可不用添加) -&gt; 点击确定按钮
</code></pre>

<p>验证环境变量</p>

<pre><code>1.win+r 或者 开始 -&gt; 搜索框输入cmd

2.在界面运行java -version

3.出现版本即可
</code></pre>

<h4 id="toc_7">macOS</h4>

<p>安装JDK</p>

<pre><code>安装 jdk-8u151-macosx-x64.dmg
</code></pre>

<p>配置环境变量</p>

<pre><code>1.进入命令行， vim ~/.bash_profile 
2.# set jdk1.8
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
PATH=$PATH:$JAVA_HOME/bin
export JAVA_HOME CLASSPATH
export PATH
</code></pre>

<p>验证</p>

<pre><code>1.打开终端

2.在界面运行java -version

3.出现版本即可
</code></pre>

<h3 id="toc_8">02.2 AndroidSDK环境</h3>

<h4 id="toc_9">windows</h4>

<p>将SDK保存到硬盘</p>

<pre><code>Android SDK文件夹解压到任意目录(记住这个目录的位置，目录不要有中文)
</code></pre>

<p>配置环境变量</p>

<pre><code>1.进入我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量

2.在系统变量下点击新建 -&gt; 变量名: ANDROID_HOME -&gt; 变量值: D:\android-sdk -&gt; 点击确定按钮

3.在系统变量下找到系统的path变量，最后添加：;%ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools;(最前面是一个分号，如果path变量最后已有分号，可不用添加) -&gt; 点击确定按钮
</code></pre>

<p>验证环境变量</p>

<pre><code>重启命令行工具，命令行输入adb，不报错即可
</code></pre>

<h4 id="toc_10">macOS</h4>

<p>将SDK保存到硬盘</p>

<pre><code>Android SDK文件夹解压到任意目录(记住这个目录的位置，目录不要有中文)
</code></pre>

<p>配置环境变量</p>

<pre><code>1.进入命令行， vim ~/.bash_profile
2.# set android
ANDROID_HOME=电脑存放的路径/android-sdk-macosx

PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools

export ANDROID_HOME 
export PATH
</code></pre>

<p>验证环境变量</p>

<pre><code>重启命令行工具，命令行输入adb，不报错即可
</code></pre>

<h4 id="toc_11">可能出现的问题</h4>

<ul>
<li>尽量不要手写</li>
<li>注意分号</li>
<li>配置好以后，cmd需要重启再输入adb</li>
<li>选择androidSDK的目录，不是jdk的目录</li>
</ul>

<h4 id="toc_12">补充：下载其他版本SDK</h4>

<p>1.win或mac的命令行中输入android</p>

<p>2.因国外下载较慢，所以需要配置国内镜像</p>

<p><strong>windows</strong></p>

<pre><code>在弹出的Android SDk Manager页面，点击Tools ，下拉框点击Options...
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180122_7.png" alt="Snip20180122_6"/></p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180122_8.png" alt="Snip20180122_6"/></p>

<p><strong>mac</strong></p>

<pre><code>点击Android SDk Manager，点击preferences
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180122_6.png" alt="Snip20180122_6"/></p>

<pre><code>镜像地址列表(也可以网上查找最新的)：

    中国科学院开源协会镜像站地址:

        IPV4/IPV6: mirrors.opencas.cn 端口：80

        IPV4/IPV6: mirrors.opencas.org 端口：80

        IPV4/IPV6: mirrors.opencas.ac.cn 端口：80

    上海GDG镜像服务器地址:

        sdk.gdgshanghai.com 端口：8000

    北京化工大学镜像服务器地址:

        IPv4: ubuntu.buct.edu.cn/ 端口：80

        IPv4: ubuntu.buct.cn/ 端口：80

        IPv6: ubuntu.buct6.edu.cn/ 端口：80

    大连东软信息学院镜像服务器地址:

        mirrors.neusoft.edu.cn 端口：80
</code></pre>

<h3 id="toc_13">02.3 Android模拟器安装</h3>

<h4 id="toc_14">windows</h4>

<p>模拟器Genymotion安装</p>

<pre><code>1.执行genymotion-2.11.0-vbox.exe(是一个集合程序，包含genymotion和virtualbox) -&gt; 不需要更改配置，直接下一步默认安装

2.安装完genymotion继续等待，会提示安装virtualbox，继续安装，期间会提示安装oracle插件，全部允许安装

3.安装完成后会在桌面展示genymotion和virtualbox两个图标
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180122_4.jpg" alt="Snip20180122_4"/></p>

<p>虚拟机镜像导入</p>

<pre><code>1.打开virtualbox

2.进入virtualbox -&gt; 管理 -&gt; 导入虚拟电脑

3.点击文件选择(Samsung Galaxy S6 - 5.1.0 - API 22 - 1440x2560.ova) -&gt; 点击下一步

4.勾选 重新初始化所有网卡的MAC地址

5.点击导入按钮 -&gt; 等待倒入完成

6.virtualbox列表会展示如下图圈出的选项
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180122_3.png" alt="Snip20180122_4"/></p>

<p>启动android模拟器</p>

<pre><code>1.点击genymotion图标 -&gt; 弹出框点击 &gt;Personal Use

2.同意条款

3.genymotion主界面选择系统后点机start按钮

4.启动成功
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180122_2.png" alt="Snip20180122_4"/></p>

<h4 id="toc_15">macOS</h4>

<p>请阅读Windows的使用方法后再阅读mac，因为两者基本一致。</p>

<p>模拟器Genymotion安装</p>

<pre><code>1.安装VirtualBox-5.1.30-OSX.dmg

2.安装genymotion-2.11.0.dmg
</code></pre>

<p>虚拟机镜像导入</p>

<pre><code>1.双击Samsung Galaxy S6 - 5.1.0 - API 22 - 1440x2560.ova

2.点击导入
</code></pre>

<p>启动android模拟器</p>

<pre><code>同 windows
</code></pre>

<h4 id="toc_16">可能出现的问题</h4>

<ul>
<li>VirtualBox 创建com对象失败 应用程序被中断

<ul>
<li><a href="https://www.cnblogs.com/iluzhiyong/p/5597557.html">https://www.cnblogs.com/iluzhiyong/p/5597557.html</a></li>
</ul></li>
<li>genymotion unable to start the virtual XXXXXX

<ul>
<li>更新vm</li>
<li>管理 - 检查更新</li>
</ul></li>
</ul>

<h4 id="toc_17">为虚拟机提供安装apk功能</h4>

<pre><code>1.安装genymotion ARM插件，此插件可提供x86运行环境，即可运行apk，需要下载对应版本的插件(本次使用android 5.1版本插件)

2.拖动ARM_Translation_Lollipop_20160402.zip到已启动的android虚拟机上

3.点击提示的ok按钮

4.重启后生效
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180122_1.png" alt="Snip20180122_4"/></p>

<h4 id="toc_18">补充：下载其他版本模拟器</h4>

<p>需要注册一个genymotion账号，官网：<a href="https://www.genymotion.com">https://www.genymotion.com</a></p>

<p>进入genymotion，点击Add按钮</p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180123_1.png" alt="Snip20180122_4"/></p>

<p>点击Sign in，输入注册的genymotion用户名和密码</p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180123_2.png" alt="Snip20180122_4"/></p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180123_3.png" alt="Snip20180122_4"/></p>

<p>选择下载需要版本的模拟器</p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180123_4.png" alt="Snip20180122_4"/></p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180123_5.png" alt="Snip20180122_4"/></p>

<p>等待下载完成(下载时间根据网络)</p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180123_6.png" alt="Snip20180122_4"/></p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/Snip20180123_7.png" alt="Snip20180122_4"/></p>

<h2 id="toc_19">03.包名和启动名</h2>

<h3 id="toc_20">03.1 包名</h3>

<p>决定程序的唯一性（不是应用的名字）</p>

<h3 id="toc_21">03.2 启动名</h3>

<p><strong>目前可以理解</strong>，一个启动名，对应着一个界面。</p>

<h2 id="toc_22">04.adb命令介绍</h2>

<h3 id="toc_23">04.1 adb的含义</h3>

<p>ADB全名Andorid Debug Bridge。 是一个Debug工具。为何称之为Bridge呢？因为adb是一个标准的C/S结构的工具, 是要连接开发电脑和调试手机的。包含如下几个部分:</p>

<pre><code>1.Client端，运行在开发机器中，即你的开发PC机。用来发送adb命令。
2.Daemon守护进程, 运行在调试设备中, 即的调试手机或模拟器。
3.Server端, 作为一个后台进程运行在开发机器中, 即你的开发PC机. 用来管理PC中的Client端和手机的Daemon之间的通信。
</code></pre>

<h3 id="toc_24">04.2 adb常用命令</h3>

<h4 id="toc_25">adb帮助</h4>

<pre><code>adb --help
</code></pre>

<h4 id="toc_26">启动adb server</h4>

<pre><code>adb start-server
</code></pre>

<h4 id="toc_27">关闭adb server</h4>

<pre><code>adb kill-server
</code></pre>

<h4 id="toc_28">获取设备号</h4>

<pre><code>adb devices
</code></pre>

<h4 id="toc_29">获取系统版本</h4>

<pre><code>adb -s 设备号 shell getprop ro.build.version.release
</code></pre>

<h4 id="toc_30">发送文件到手机</h4>

<pre><code>adb push 电脑端文件路径/需要发送的文件  手机端存储的路径

示例：
    将桌面的xx.png发送到手机sdcard目录下
    adb push C:\Users\win\Desktop\xx.png  /sdcard
</code></pre>

<h4 id="toc_31">从手机拉取文件</h4>

<pre><code>adb pull 手机端的路径/拉取文件名 电脑端存储文件路径

示例：
    将手机/sdcard目录中的xx.png文件，发送到电脑桌面
    adb pull /sdcard/xx.png C:\Users\win\Desktop
</code></pre>

<h4 id="toc_32">查看手机运行日志</h4>

<pre><code>adb logcat
</code></pre>

<h4 id="toc_33">手机shell命令行</h4>

<pre><code>adb shell
</code></pre>

<h4 id="toc_34">获取app包名和启动名</h4>

<p>手机需要先打开对应app</p>

<pre><code>1.Mac/Linux: &#39;adb shell dumpsys window windows | grep mFocusedApp’
2.在 Windows 终端运行 &#39;adb shell dumpsys window windows’ 然后去看mFocusedApp这一行的内容。
</code></pre>

<h4 id="toc_35">安装app到手机</h4>

<pre><code>adb install 路径/xx.apk
</code></pre>

<h4 id="toc_36">卸载手机手机app</h4>

<pre><code>adb uninstall 包名
</code></pre>

<h4 id="toc_37">获取app启动时间</h4>

<pre><code>adb shell am start -W 包名/启动名

示例：
    adb shell am start -W com.yly.drawpic/.MainActivity
解释：
    ThisTime  该activity启动耗时
    TotalTime  应用自身启动耗时 = ThisTime + 应用application等资源启动时间
    WaitTime  系统启动应用耗时 = TotalTime + 系统资源启动时间
</code></pre>

<h2 id="toc_38">05.移动端自动化测试工具</h2>

<h3 id="toc_39">05.1 主流的移动端自动化工具</h3>

<ul>
<li>Robotium</li>
</ul>

<p>​    1.支持语言：Java</p>

<p>​    2.仅支持Android系统</p>

<p>​    3.不支持跨应用</p>

<ul>
<li>Macaca</li>
</ul>

<p>​    1.支持语言：Java，Python，Node.js</p>

<p>​    2.支持Android和iOS系统</p>

<p>​    3.支持跨应用</p>

<ul>
<li>Appium</li>
</ul>

<p>​    1.支持语言：Java，C#，Python，php，perl，ruby，Node.js</p>

<p>​    2.支持Android和iOS系统</p>

<p>​    3.支持跨应用</p>

<ul>
<li>自动化工具选择的关注点</li>
</ul>

<p>​    1.是否支持native，webview</p>

<p>​    2.是否支持获取toast</p>

<p>​    3.是否支持跨应用</p>

<h3 id="toc_40">05.2 Appium介绍</h3>

<p>Appium是一个移动端的自动化框架，可用于测试原生应用，移动网页应用和混合型应用，且是跨平台的。可用于iOS和Android以及firefox的操作系统。原生的应用是指用android或ios的sdk编写的应用，移动网页应用是指网页应用，类似于ios中safari应用或者Chrome应用或者类浏览器的应用。混合应用是指一种包裹webview的应用,原生应用于网页内容交互性的应用。<br/>
重要的是Appium是跨平台的，何为跨平台，意思就是可以针对不同的平台用一套api来编写测试用例。</p>

<h3 id="toc_41">05.3 Appium特点</h3>

<p>1.使用自动化来测试一个app，但是不需要重新编译它<br/>
2.写自动化case，不需要学习特定的语言<br/>
3.一个自动化框架不需要重复造轮子<br/>
4.一个自动化框架需要开源，在精神和实践上实现开源</p>

<h3 id="toc_42">05.4 Appium自动化测试环境搭建</h3>

<p>我们使用Appium和python来进行自动化测试，需要安装两个东西，一个是Appium的客户端，一个是Appium-python库。这两个需要安装的东西在加上手机就可以进行自动化测试，它们之间的关系是：python代码 -&gt; Appium-python库 -&gt; Appium -&gt; 手机。</p>

<h4 id="toc_43">Appium客户端安装</h4>

<h5 id="toc_44">Appium背景介绍</h5>

<pre><code>1.官网：www.appium.io,由SauceLab公司开发

2.Appium是由nodejs的express框架写的Http Server,Appium使用WebDriver的json wire协议，来驱动Apple系统的UIAutomation库、Android系统的UIAutomator框架
</code></pre>

<h5 id="toc_45">Appium桌面客户端安装方式</h5>

<pre><code>1. 运行appium-desktop-Setup-1.2.7.exe，默认安装即可
2. 启动客户端，按图片步骤 1 -&gt; 2 -&gt; 3 -&gt; 4 设置
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/%E5%90%AF%E5%8A%A8appium.png" alt="启动appium界面"/></p>

<pre><code>3. 启动成功展示如下图
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="appium启动成功"/></p>

<h5 id="toc_46">Appium命令行安装方式</h5>

<pre><code>1. 安装Node.js -&gt;Win:官网下载可执行包安装(Linux: yum install; Macos: brew install)
2. 安装完成后 命令行运行npm或node -v 来查看是否安装成功
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/node.png" alt="node"/> </p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/npm.png" alt="npm"/></p>

<pre><code>敲黑板: npm国内一般被墙，所以选择淘宝镜像安装，官网:http://npm.taobao.org
3. 安装cnpm: npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/cnpm.png" alt="cnpm"/></p>

<pre><code>4. 安装appium: cnpm install -g appium
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/appium_install.png" alt="appium_install"/> <img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/appium_result.png" alt="appium_result"/></p>

<pre><code>4. 启动appium服务命令: appium &amp;，如下图即正确安装
敲黑板: Windows安装会提示os的模块错误，这个需要mac系统支持，不影响windows操作使用
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/appium_start.png" alt="appium_start"/></p>

<h4 id="toc_47">Appium-python库安装</h4>

<h5 id="toc_48">命令行安装(需要联网)</h5>

<pre><code>pip3 install Appium-Python-Client
</code></pre>

<h5 id="toc_49">安装包安装</h5>

<pre><code>前提：python已安装setuptools包
安装setuptools:
    1.解压setuptools-38.2.4.zip
    2.进入解压后文件夹执行命令: python setup.py install
    3.等待安装完成，无错误信息即可

安装Appium-Python-Client:
    1.解压Appium-Python-Client-0.25.tar.gz
    2.进入解压后文件夹执行命令: python setup.py install
    3.等待安装完成，无错误信息即可
</code></pre>

<h2 id="toc_50">06.Hello Appium</h2>

<h3 id="toc_51">需求</h3>

<p>使用Python打开android模拟器中的设置界面。</p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90.gif" alt=""/></p>

<h3 id="toc_52">思路</h3>

<p>python代码到手机的过程是需要先经过Appium-python库再经过Appium再到手机。也就是python代码 -&gt; Appium-python库 -&gt; Appium -&gt; 手机。</p>

<h3 id="toc_53">方法</h3>

<pre><code>  from appium import webdriver

  import time

  # server 启动参数
  desired_caps = {}
  # 设备信息
  desired_caps[&#39;platformName&#39;] = &#39;Android&#39;
  desired_caps[&#39;platformVersion&#39;] = &#39;5.1&#39;
  desired_caps[&#39;deviceName&#39;] = &#39;192.168.56.101:5555&#39;
  # app信息
  desired_caps[&#39;appPackage&#39;] = &#39;com.android.settings&#39;
  desired_caps[&#39;appActivity&#39;] = &#39;.Settings&#39;

  driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)

  # time.sleep(2)

  # driver.quit()
</code></pre>

<h2 id="toc_54">07.Appium 基础API</h2>

<h3 id="toc_55">App基础操作API</h3>

<h4 id="toc_56">前置代码</h4>

<pre><code>  # server 启动参数

  desired_caps = {}
  desired_caps[&#39;platformName&#39;] = &#39;Android&#39; 
  desired_caps[&#39;platformVersion&#39;] = &#39;5.1&#39;
  desired_caps[&#39;deviceName&#39;] = &#39;192.168.56.101:5555&#39;
  desired_caps[&#39;appPackage&#39;] = &#39;com.android.settings&#39;
  desired_caps[&#39;appActivity&#39;] = &#39;.Settings&#39;
  desired_caps[&#39;unicodeKeyboard&#39;] = True
  desired_caps[&#39;resetKeyboard&#39;] = True

  # 声明driver对象
  driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps)

</code></pre>

<h4 id="toc_57">获取app包名和启动名</h4>

<pre><code>    获取包名方法：current_package
    获取启动名：current_activity
</code></pre>

<pre><code>    业务场景：
        1.启动设置
        2.获取包名和启动名
</code></pre>

<pre><code>    代码实现：
        print(driver.current_package)
        print(driver.current_activity)
    执行结果：
        com.tencent.news
        .activity.SplashActivity
</code></pre>

<h4 id="toc_58">脚本内启动其他app</h4>

<pre><code>    driver.start_activity(appPackage,appActivity)
    参数：
        appPackage：包名
        appActivity：启动名
    示例：
        driver.start_activity(&#39;com.android.mms&#39;, &#39;.ui.ConversationList&#39;)
</code></pre>

<h4 id="toc_59">关闭app</h4>

<pre><code>    driver.close_app()  # 关闭当前操作的app，不会关闭驱动对象
</code></pre>

<h4 id="toc_60">关闭驱动对象</h4>

<pre><code>    driver.quit()   # 关闭驱动对象，同时关闭所有关联的app
</code></pre>

<h4 id="toc_61">安装APK到手机</h4>

<pre><code>    driver.install_app(app_path) 
    参数：
        app_path：脚本机器中APK文件路径
    示例：
        driver.install_app(&quot;/Users/Yoson/Downloads/anzhishichang_6450.apk&quot;)
</code></pre>

<h4 id="toc_62">手机中移除APP</h4>

<pre><code>    driver.remove_app(app_id) 
    参数：
        app_id：需要卸载的app包名
    示例：
        driver.remove_app(&#39;cn.goapk.market&#39;)
</code></pre>

<h4 id="toc_63">判断APP是否已安装</h4>

<pre><code>    driver.is_app_installed(app_id) 
    参数：
        bundle_id: 可以传入app包名,返回结果为True(已安装) / False(未安装)
    示例：
    print(driver.is_app_installed(&#39;cn.goapk.market&#39;))
</code></pre>

<h4 id="toc_64">发送文件到手机</h4>

<pre><code>    import base64
    data = str(base64.b64encode(data.encode(&#39;utf-8&#39;)),&#39;utf-8&#39;)
    driver.push_file(path,data)
    参数：
        path：手机设备上的路径(例如：/sdcard/a.txt)
        data：文件内数据,要求base64编码
        Python3.x中字符都为unicode编码，而b64encode函数的参数为byte类型，需要先转码；生成的数据为byte类型，需要将byte转换回去。
    示例：
        import base64
        data = str(base64.b64encode(&#39;test 123&#39;.encode(&#39;utf-8&#39;)), &#39;utf-8&#39;)
        driver.push_file(&#39;/sdcard/test.txt&#39;, data)
</code></pre>

<h4 id="toc_65">从手机中拉取文件</h4>

<pre><code>    import base64
    data = driver.pull_file(path) # 返回数据为base64编码
    print(str(base64.b64decode(data),&#39;utf-8&#39;)) # base64解码
    参数：
        path: 手机设备上的路径
    示例：
        import base64
        data = driver.pull_file(&#39;/sdcard/test.txt&#39;) # 返回数据为base64编码
        print(str(base64.b64decode(data), &#39;utf-8&#39;)) # base64解码
</code></pre>

<h4 id="toc_66">获取当前屏幕内元素结构</h4>

<pre><code>    driver.page_source  
    作用：
        返回当前页面的文档结构，判断特定的元素是否存在
    示例：
        print(driver.page_source)
</code></pre>

<h4 id="toc_67">应用置于后台事件</h4>

<pre><code>    APP放置后台，模拟热启动
    方法：background_app(seconds)
    参数：
        1.seconds:停留在后台的时间，单位：秒
</code></pre>

<pre><code>    业务场景：
        1.进入设置页
        2.将APP置于后台5s
</code></pre>

<pre><code>    代码实现：
        driver.background_app(5)
    效果：
        app置于后台5s后，再次展示当前页面
</code></pre>

<h2 id="toc_68">08.UIAutomatorViewer</h2>

<h3 id="toc_69">工具简介</h3>

<p>用来扫描和分析Android应用程序的UI控件的工具.</p>

<h3 id="toc_70">如何使用</h3>

<p>1.进入SDK目录下的tools目录，打开uiautomatorviewer</p>

<p>2.电脑连接真机或打开android模拟器</p>

<p>3.启动待测试app</p>

<p>4.点击uiautomatorviewer的左上角Device Screenshot,会生成app当前页面的UI控件截图</p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/UI01.png" alt="Snip20180122_4"/></p>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/UI02.png" alt="Snip20180122_4"/></p>

<h2 id="toc_71">09.元素定位API</h2>

<pre><code>手工测试主要通过可见按钮操作，而自动化是通过元素进行交互操作.
⚠️⚠️⚠️ 元素的基本定位基于当前屏幕范围内展示的可见元素。
</code></pre>

<ul>
<li>Appium常用元素定位方式</li>
</ul>

<table>
<thead>
<tr>
<th>name</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td>id</td>
<td>id属性值</td>
</tr>
<tr>
<td>class</td>
<td>class属性值</td>
</tr>
<tr>
<td>xpath</td>
<td>xpath表达式</td>
</tr>
</tbody>
</table>

<ul>
<li>前置代码</li>
</ul>

<pre><code>    from appium import webdriver
    # server 启动参数
    desired_caps = {}
    # 设备信息
    desired_caps[&#39;platformName&#39;] = &#39;Android&#39;
    desired_caps[&#39;platformVersion&#39;] = &#39;5.1&#39;
    desired_caps[&#39;deviceName&#39;] = &#39;192.168.56.101:5555&#39;
    # app的信息
    desired_caps[&#39;appPackage&#39;] = &#39;com.android.settings&#39;
    desired_caps[&#39;appActivity&#39;] = &#39;.Settings&#39;

    # 声明我们的driver对象
    driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps)
</code></pre>

<h3 id="toc_72">定位一个元素 element</h3>

<h4 id="toc_73">通过id定位</h4>

<pre><code>    方法：find_element_by_id(id_value) # id_value:为元素的id属性值
</code></pre>

<pre><code>    业务场景:
        1.进入设置页面
        2.通过ID定位方式点击搜索按钮
</code></pre>

<pre><code>    代码实现：
        driver.find_element_by_id(&quot;com.android.settings:id/search&quot;).click()
        driver.quit()
</code></pre>

<h4 id="toc_74">通过class定位</h4>

<pre><code>    方法：find_element_by_class_name(class_value) # class_value:为元素的class属性值
</code></pre>

<pre><code>    业务场景:
        1.进入设置页面
        2.点击搜索按钮
        3.通过class定位方式点击输入框的返回按钮
</code></pre>

<pre><code>    代码实现：
        # id 点击搜索按钮
        driver.find_element_by_id(&quot;com.android.settings:id/search&quot;).click()
        # class 点击输入框返回按钮
        driver.find_element_by_class_name(&#39;android.widget.ImageButton&#39;).click()
        driver.quit()
</code></pre>

<h4 id="toc_75">通过xpath定位</h4>

<pre><code>    方法：find_element_by_xpath(xpath_value) # xpath_value:为可以定位到元素的xpath语句
</code></pre>

<pre><code>    *** android端xptah常用属性定位：
        1. id ://*[contains(@resource-id,&#39;com.android.settings:id/search&#39;)] 
        2. class ://*[contains(@class,&#39;android.widget.ImageButton&#39;)]
        3. text ://*[contains(@text,&#39;WLA&#39;)]

    *** 模糊定位 contains(@key,value): value可以是部分值
</code></pre>

<pre><code>    业务场景:
        1.进入设置页面
        2.点击WLAN菜单栏
</code></pre>

<pre><code>    代码实现：
        # xpath 点击WLAN按钮
        driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;WLA&#39;)]&quot;).click()
</code></pre>

<h3 id="toc_76">定位一组元素 elements</h3>

<pre><code>    应用场景为元素值重复，无法通过元素属性直接定位到某个元素，只能通过elements方式来选择，返回一个定位对象的列表.
</code></pre>

<h4 id="toc_77">通过id方式定位一组元素</h4>

<pre><code>    方法： find_elements_by_id(id_value) # id_value:为元素的id属性值
</code></pre>

<pre><code>    业务场景:
        1.进入设置页面
        2.点击WLAN菜单栏(id定位对象列表中第1个)
</code></pre>

<pre><code>    代码实现：
        # 定位到一组元素
        title = driver.find_elements_by_id(&quot;com.android.settings:id/title&quot;)
        # 打印title类型，预期为list
        print(type(title))
        # 取title返回列表中的第一个定位对象，执行点击操作
        title[0].click()
</code></pre>

<h4 id="toc_78">通过class方式定位一组元素</h4>

<pre><code>    方法：find_elements_by_class_name(class_value) # class_value:为元素的class属性值
</code></pre>

<pre><code>    业务场景:
        1.进入设置页面
        2.点击WLAN菜单栏(class定位对象列表中第3个)
</code></pre>

<pre><code>    代码实现：
        # 定位到一组元素
        title = driver.find_elements_by_class_name(&quot;android.widget.TextView&quot;)
        # 打印title类型，预期为list
        print(type(title))
        # 取title返回列表中的第一个定位对象，执行点击操作
        title[3].click()
</code></pre>

<h4 id="toc_79">通过xpath方式定位一组元素</h4>

<pre><code>    方法:find_elements_by_xpath(xpath_value) # xpath_value:为可以定位到元素的xpath语句
</code></pre>

<pre><code>    业务场景:
        1.进入设置页面
        2.点击WLAN菜单栏(xpath中class属性定位对象列表中第3个)
</code></pre>

<pre><code>    代码实现：
        # 定位到一组元素
        title = driver.find_elements_by_xpath(&quot;//*[contains(@class,&#39;widget.TextView&#39;)]&quot;)
        # 打印title类型，预期为list
        print(type(title))
        # 取title返回列表中的第一个定位对象，执行点击操作
        title[3].click()
</code></pre>

<h3 id="toc_80">WebDriverWait 显示等待</h3>

<pre><code>    在一个超时时间范围内，每隔一段时间去搜索一次元素是否存在，
    如果存在返回定位对象，如果不存在直到超时时间到达，报超时异常错误。
</code></pre>

<pre><code>    方法:WebDriverWait(driver, timeout, poll_frequency).until(method)
    参数：
        1.driver：手机驱动对象
        2.timeout：搜索超时时间
        3.poll_frequency：每次搜索间隔时间，默认时间为0.5s
        4.method：定位方法(匿名函数)
</code></pre>

<pre><code>    匿名函数: 
        lambda x: x
    等价于python函数：
        def test(x):
            return x
</code></pre>

<pre><code>    使用示例：
        from selenium.webdriver.support.wait import WebDriverWait
        WebDriverWait(driver, timeout, poll_frequency).until(lambda x: x.find_elements_by_id(id_value))
    解释：
        1.x传入值为：driver，所以才可以使用定位方法.
    函数运行过程：
        1.实例化WebDriverWait类，传入driver对象，之后driver对象被赋值给WebDriverWait的一个类变量：self._driver
        2.until为WebDriverWait类的方法，until传入method方法(即匿名函数)，之后method方法会被传入self._driver
        3.搜索到元素后until返回定位对象，没有搜索到函数until返回超时异常错误.
</code></pre>

<pre><code>    业务场景:
        1.进入设置页面
        2.通过ID定位方式点击搜索按钮
</code></pre>

<pre><code>    代码实现：
        from selenium.webdriver.support.wait import WebDriverWait # 导入WebDriverWait类
        # 超时时间为30s，每隔1秒搜索一次元素是否存在，如果元素存在返回定位对象并退出
        search_button = WebDriverWait(driver, 30, 1).until(lambda x: x.find_elements_by_id(com.android.settings:id/search))
        search_button.click()
        driver.quit()
</code></pre>

<h2 id="toc_81">10.元素操作API</h2>

<pre><code>    本节讲介绍手机端元素信息的获取以及基本的输入操作。
</code></pre>

<ul>
<li>前置代码</li>
</ul>

<pre><code>    from appium import webdriver
    # server 启动参数
    desired_caps = {}
    # 设备信息
    desired_caps[&#39;platformName&#39;] = &#39;Android&#39;
    desired_caps[&#39;platformVersion&#39;] = &#39;5.1&#39;
    desired_caps[&#39;deviceName&#39;] = &#39;192.168.56.101:5555&#39;
    # app的信息
    desired_caps[&#39;appPackage&#39;] = &#39;com.android.settings&#39;
    desired_caps[&#39;appActivity&#39;] = &#39;.Settings&#39;

    # 声明我们的driver对象
    driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps)
</code></pre>

<h3 id="toc_82">点击元素</h3>

<pre><code>    方法：click() 
</code></pre>

<pre><code>    业务场景:
        1.打开设置
        2.点击搜索按钮
</code></pre>

<pre><code>    代码实现：
        # 点击搜索按钮
        driver.find_element_by_id(&quot;com.android.settings:id/search&quot;).click()
</code></pre>

<h3 id="toc_83">发送数据到输入框</h3>

<pre><code>    方法：send_keys(vaue) # value：需要发送到输入框内的文本
</code></pre>

<pre><code>    业务场景:
        1.打开设置
        2.点击搜索按钮
        3.输入内容abc
</code></pre>

<pre><code>    代码实现：
        # 点击搜索按钮
        driver.find_element_by_id(&quot;com.android.settings:id/search&quot;).click()
        # 定位到输入框并输入abc
        driver.find_element_by_id(&quot;android:id/search_src_text&quot;).send_keys(&quot;abc&quot;)

    重点:
        大家可以将输入的abc 改成 输入中文，得到的结果:输入框无任何值输入且程序不会抱错
</code></pre>

<pre><code>    解决输入中文问题：

        1.server 启动参数增加两个参数配置
            desired_caps[&#39;unicodeKeyboard&#39;] = True
            desired_caps[&#39;resetKeyboard&#39;] = True

        2.再次运行会发现运行成功
            # 点击搜索按钮
            driver.find_element_by_id(&quot;com.android.settings:id/search&quot;).click()
            # 定位到输入框并输入abc
            driver.find_element_by_id(&quot;android:id/search_src_text&quot;).send_keys(&quot;传智播客&quot;)
</code></pre>

<h3 id="toc_84">清空输入框内容</h3>

<pre><code>    方法：clear()
</code></pre>

<pre><code>    业务场景:
        1.打开设置
        2.点击搜索按钮
        3.输入内容abc
        4.删除已输入abc
</code></pre>

<pre><code>    代码实现：
        # 点击搜索按钮
        driver.find_element_by_id(&quot;com.android.settings:id/search&quot;).click()
        # 定位到输入框并输入abc
        input_text = driver.find_element_by_id(&quot;android:id/search_src_text&quot;)
        # 输入abc
        input_text.send_keys(&quot;abc&quot;)
        time.sleep(1)
        # 删除abc
        input_text.clear()
</code></pre>

<h3 id="toc_85">获取元素的文本内容</h3>

<pre><code>    方法: text
</code></pre>

<pre><code>    业务场景：
        1.进入设置
        2.获取所有元素class属性为“android.widget.TextView”的文本内容
</code></pre>

<pre><code>    代码实现：
        text_vlaue = driver.find_elements_by_class_name(&quot;android.widget.TextView&quot;)
        for i in text_vlaue:
            print(i.text)
    执行结果：
        设置

        无线和网络
        WLAN
        更多
        设备
        显示
        提示音和通知
        存储
</code></pre>

<h3 id="toc_86">获取元素的属性值</h3>

<pre><code>    方法: get_attribute(value) # value:元素的属性
    ⚠️ value=&#39;name&#39; 返回content-desc / text属性值
    ⚠️ value=&#39;text&#39; 返回text的属性值
    ⚠️ value=&#39;className&#39; 返回 class属性值，只有 API=&gt;18 才能支持
    ⚠️ value=&#39;resourceId&#39; 返回 resource-id属性值，只有 API=&gt;18 才能支持
</code></pre>

<pre><code>    业务场景：
        1.进入设置
        2.获取搜索按钮的content-desc属性值
</code></pre>

<p><img src="%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/%E6%90%9C%E7%B4%A2%E5%B1%9E%E6%80%A7.png" alt="搜索属性"/><br/>
<code><br/>
    代码实现：<br/>
        # 定位到搜索按钮<br/>
        get_value = driver.find_element_by_id(&quot;com.android.settings:id/search&quot;)<br/>
        print(get_value.get_attribute(&quot;name&quot;))<br/>
    执行结果：<br/>
        搜索<br/>
</code></p>

<h3 id="toc_87">获取元素在屏幕上的坐标</h3>

<pre><code>    方法:location
</code></pre>

<pre><code>    业务场景：
        1.进入设置页面
        2.获取搜索按钮在屏幕的坐标位置
</code></pre>

<pre><code>    代码实现:
        # 定位到搜索按钮
        get_value = driver.find_element_by_id(&quot;com.android.settings:id/search&quot;)
        # 打印搜索按钮在屏幕上的坐标
        print(get_value.location)
    执行结果:
        {&#39;y&#39;: 44, &#39;x&#39;: 408}
</code></pre>

<h2 id="toc_88">11.滑动和拖拽事件</h2>

<ul>
<li>前置代码</li>
</ul>

<pre><code>    from appium import webdriver
    # server 启动参数
    desired_caps = {}
    # 设备信息
    desired_caps[&#39;platformName&#39;] = &#39;Android&#39;
    desired_caps[&#39;platformVersion&#39;] = &#39;5.1&#39;
    desired_caps[&#39;deviceName&#39;] = &#39;192.168.56.101:5555&#39;
    # app的信息
    desired_caps[&#39;appPackage&#39;] = &#39;com.android.settings&#39;
    desired_caps[&#39;appActivity&#39;] = &#39;.Settings&#39;

    # 声明我们的driver对象
    driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps)
</code></pre>

<h3 id="toc_89">swipe 滑动事件</h3>

<pre><code>    ⚠️从一个坐标位置滑动到另一个坐标位置,只能是两个点之间的滑动
    方法：swipe(start_x, start_y, end_x, end_y, duration=None)
    参数：
        1.start_x：起点X轴坐标
        2.start_y：起点Y轴坐标
        3.end_x：  终点X轴坐标
        4.end_y,： 终点Y轴坐标
        5.duration： 滑动这个操作一共持续的时间长度，单位：ms
</code></pre>

<pre><code>    业务场景：
        1.进入设置
        2.从坐标(148,659)滑动到坐标(148,248)
</code></pre>

<pre><code>    代码实现：
        # 滑动没有持续时间
        driver.swipe(188,659,148,248)
        # 滑动持续5秒的时间
        driver.swipe(188,659,148,248,5000)
</code></pre>

<h3 id="toc_90">scroll 滑动事件</h3>

<pre><code>    ⚠️ 从一个元素滑动到另一个元素，直到页面自动停止
    方法：scroll(origin_el, destination_el)
    参数：
        1.origin_el：滑动开始的元素
        2.destination_el：滑动结束的元素
</code></pre>

<pre><code>    业务场景：
        1.进入设置页
        2.模拟手指从存储菜单位置 到 WLAN菜单位置的上滑操作
</code></pre>

<pre><code>    代码实现：
        # 定位到存储菜单栏
        el1 = driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;存储&#39;)]&quot;)
        # 定位到WLAN菜单栏
        el2 = driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;WLAN&#39;)]&quot;)
        # 执行滑动操作
        driver.scroll(el1,el2)
</code></pre>

<h3 id="toc_91">drag 拖拽事件</h3>

<pre><code>    ⚠️ 从一个元素滑动到另一个元素,第二个元素替代第一个元素原本屏幕上的位置
    方法：drag_and_drop(origin_el, destination_el)
    参数：
        1.origin_el：滑动开始的元素
        2.destination_el：滑动结束的元素
</code></pre>

<pre><code>    业务场景：
        1.进入设置页
        2.模拟手指将存储菜单 滑动到 WLAN菜单栏位置
</code></pre>

<pre><code>    代码实现：
        # 定位到存储菜单栏
        el1 = driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;存储&#39;)]&quot;)
        # 定位到WLAN菜单栏
        el2 = driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;WLAN&#39;)]&quot;)
        # 执行滑动操作
        driver.drag_and_drop(el1,el2)
</code></pre>

<h2 id="toc_92">12.高级手势TouchAction</h2>

<pre><code>    TouchAction是AppiumDriver的辅助类，主要针对手势操作，比如滑动、长按、拖动等，
    原理是将一系列的动作放在一个链条中发送到服务器，服务器接受到该链条后，解析各个动作，逐个执行。
</code></pre>

<p>⚠️ 所有手势都要通过执行perform()函数才会运行.</p>

<h3 id="toc_93">手指轻敲操作</h3>

<pre><code>    模拟手指轻敲一下屏幕操作
    方法：tap(element=None, x=None, y=None)
    方法：perform() # 发送命令到服务器执行操作
    参数：
        1.element：被定位到的元素
        2.x：相对于元素左上角的坐标，通常会使用元素的X轴坐标
        3.y：通常会使用元素的Y轴坐标
</code></pre>

<pre><code>    业务场景：
        1.进入设置
        2.点击WLAN选项
</code></pre>

<pre><code>    代码实现：
        # 通过元素定位方式敲击屏幕
        el = driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;WLAN&#39;)]&quot;)
        TouchAction(driver).tap(el).perform()

        # 通过坐标方式敲击屏幕，WLAN坐标:x=155,y=250
        # TouchAction(driver).tap(x=155,y=250).perform()
</code></pre>

<h3 id="toc_94">手指按下和抬起操作</h3>

<pre><code>    模拟手指按下屏幕,按就要对应着离开.
</code></pre>

<pre><code>    方法:press(el=None, x=None, y=None)
    方法:release() # 结束动作，手指离开屏幕
    参数：
        1.element：被定位到的元素
        2.x：通常会使用元素的X轴坐标
        3.y：通常会使用元素的Y轴坐标
</code></pre>

<pre><code>    业务场景:
        1.进入设置
        2.点击WLAN选项
</code></pre>

<pre><code>    代码实现：
        # 通过元素定位方式按下屏幕
        el = driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;WLAN&#39;)]&quot;)
        TouchAction(driver).press(el).release().perform()

        # 通过坐标方式按下屏幕，WLAN坐标:x=155,y=250
        # TouchAction(driver).tap(x=155,y=250).release().perform()
</code></pre>

<h3 id="toc_95">等待操作</h3>

<pre><code>    方法：wait(ms=0)
    参数：
        ms：暂停的毫秒数

</code></pre>

<pre><code>    业务场景:
        1.进入设置
        2.点击WLAN选项
        3.长按WiredSSID选项5秒

</code></pre>

<pre><code>    代码实现：
        # 点击WLAN
        driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;WLAN&#39;)]&quot;).click()
        # 定位到WiredSSID
        el =driver.find_element_by_id(&quot;android:id/title&quot;)
        # 通过元素定位方式长按元素
        TouchAction(driver).press(el).wait(5000).perform()

        # TouchAction(driver).press(x=171,y=245).wait(5000).release().perform() ⚠️ 该方法未能完成长按操作，没有报任何错误

</code></pre>

<h3 id="toc_96">手指长按操作</h3>

<pre><code>    模拟手机按下屏幕一段时间,按就要对应着离开.
</code></pre>

<pre><code>    方法：long_press(el=None, x=None, y=None, duration=1000)
    参数：
        1.element：被定位到的元素
        2.x：通常会使用元素的X轴坐标
        3.y：通常会使用元素的Y轴坐标
        4.duration：持续时间，默认为1000ms
</code></pre>

<pre><code>    业务场景:
        1.进入设置
        2.点击WLAN选项
        3.长按WiredSSID选项5秒
</code></pre>

<pre><code>    代码实现：
        # 点击WLAN
        driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;WLAN&#39;)]&quot;).click()
        # 定位到WiredSSID
        el =driver.find_element_by_id(&quot;android:id/title&quot;)
        # 通过元素定位方式长按元素
        TouchAction(driver).long_press(el,duration=5000).release().perform()
</code></pre>

<h3 id="toc_97">手指移动操作</h3>

<pre><code>    模拟手机的滑动操作
    方法：move_to(el=None, x=None, y=None)
    参数:
        1.el:定位的元素
        2.x:相对于前一个元素的X轴偏移量
        3.y:相对于前一个元素的Y轴偏移量
</code></pre>

<pre><code>    业务场景：
        1.进入设置
        2.向上滑动屏幕
</code></pre>

<pre><code>    代码实现：
        # 定位到存储
        el = driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;存储&#39;)]&quot;)
        # 定位到更多
        el1 = driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;更多&#39;)]&quot;)
        # 元素方式滑动
        TouchAction(driver).press(el).move_to(el1).release().perform()
        # 坐标的方式滑动
        # TouchAction(driver).press(x=240,y=600).wait(100).move_to(x=100,y=100).release().perform()

</code></pre>

<h3 id="toc_98">案例-手势解锁</h3>

<pre><code>    需求：
        1.进入设置
        2.向上滑动屏幕到可见&quot;安全&quot;选项
        3.进入到安全
        4.点击屏幕锁定方式
        5.点击图案
        6.绘制图案
</code></pre>

<pre><code>示例代码：

# 需要进入的页面
page_name = &quot;安全&quot;

# 如果找到就点击，如果没有往下滑，再次重新找，直到找到。
while True:
    try:
        driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;&quot; + page_name + &quot;&#39;)]&quot;).click()
        break
    except Exception:
        driver.swipe(100, 2000, 100, 1000)
        time.sleep(1)

driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;屏幕锁定&#39;)]&quot;).click()
time.sleep(1)
driver.find_element_by_xpath(&quot;//*[contains(@text,&#39;图案&#39;)]&quot;).click()
time.sleep(1)
TouchAction(driver).press(x=233, y=834).move_to(x=0, y=480).move_to(x=480, y=0).move_to(x=480, y=-480).move_to(x=0, y=480).move_to(x=0, y=480).release().perform()
</code></pre>

<p><img src="./%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/%E5%B1%8F%E5%B9%95%E5%9B%BE%E6%A1%88.gif" alt="屏幕图案"/></p>

<h2 id="toc_99">13.手机操作API</h2>

<pre><code>    针对手机的一些常用设置功能进行操作.
</code></pre>

<h3 id="toc_100">获取手机时间</h3>

<pre><code>    方法：device_time
</code></pre>

<pre><code>    代码实现：
        # 获取当前手机的时间
        print(driver.device_time)
    执行结果：
        Wed Dec 27 08:52:45 EST 2017
</code></pre>

<h3 id="toc_101">获取手机的宽高</h3>

<pre><code>    获取手机的宽高，可以根据宽高做一些坐标的操作
</code></pre>

<pre><code>    方法：get_window_size()
</code></pre>

<pre><code>    代码实现：
        print(driver.get_window_size())
    执行结果：
        {&#39;height&#39;: 800, &#39;width&#39;: 480}
</code></pre>

<h3 id="toc_102">发送键到设备</h3>

<pre><code>    模拟系统键值的操作，比如操作honme键，音量键,返回键等。
</code></pre>

<pre><code>    方法：keyevent(keycode, metastate=None):
    参数：
        keycode：发送给设备的关键代码
        metastate：关于被发送的关键代码的元信息，一般为默认值
</code></pre>

<pre><code>    业务场景:
        1.打开设置
        2.按多次音量增加键
</code></pre>

<pre><code>    代码实现：
        for i in range(3):
            driver.keyevent(24)
</code></pre>

<p><img src="./%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/%E9%9F%B3%E9%87%8F%E5%A2%9E%E5%8A%A0%E9%94%AE.gif" alt="音量增加键"/></p>

<h3 id="toc_103">操作手机通知栏</h3>

<pre><code>    打开手机的通知栏，可以获取通知栏的相关信息和元素操作
</code></pre>

<pre><code>    方法：open_notifications()
</code></pre>

<pre><code>    业务场景: 
        1.启动设置
        2.打开通知栏
</code></pre>

<pre><code>    代码实现：
        driver.open_notifications()
</code></pre>

<p><img src="./%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/%E9%80%9A%E7%9F%A5%E6%A0%8F.gif" alt="通知栏"/></p>

<h3 id="toc_104">获取手机当前网络</h3>

<pre><code>    获取手机当前连接的网络
</code></pre>

<pre><code>    方法：network_connection
</code></pre>

<pre><code>    业务场景:
        获取手机当前网络模式
</code></pre>

<pre><code>    代码实现：
        print(driver.network_connection)
    执行结果：
        6
</code></pre>

<p><img src="./%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.png" alt="网络模式"/></p>

<h3 id="toc_105">设置手机网络</h3>

<pre><code>    更改手机的网络模式，模拟特殊网络情况下的测试用例
</code></pre>

<pre><code>    方法：set_network_connection(connectionType)
    参数：
        connectionType：需要被设置成为的网络类型
</code></pre>

<pre><code>    业务场景：
        1.启动设置
        2.设置手机网络为飞行模式
</code></pre>

<pre><code>    代码实现：
        driver.set_network_connection(1)
</code></pre>

<p><img src="./%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/%E9%A3%9E%E8%A1%8C%E6%A8%A1%E5%BC%8F.gif" alt="飞行模式"/></p>

<h3 id="toc_106">手机截图</h3>

<pre><code>    截取手机当前屏幕，保存指定格式图片到设定位置
</code></pre>

<pre><code>    方法：get_screenshot_as_file(filename)
    参数：
        filename：指定路径下，指定格式的图片.
</code></pre>

<pre><code>    业务场景：
        1.打开设置页面
        2.截图当前页面保存到当前目录，命名为screen.png
</code></pre>

<pre><code>    代码实现：
        import os
        driver.get_screenshot_as_file(os.getcwd() + os.sep + &#39;./screen.png&#39;)
    执行结果：
        当前目录下会生成screen.png文件
</code></pre>

<h2 id="toc_107">14.Pytest安装和介绍</h2>

<ul>
<li>介绍</li>
</ul>

<pre><code>    pytest是python的一种单元测试框架，同自带的Unittest测试框架类似，相比于Unittest框架使用起来更简洁，效率更高。
</code></pre>

<ul>
<li>特点:</li>
</ul>

<pre><code>    1.非常容易上手，入门简单，文档丰富，文档中有很多实例可以参考
    2.支持简单的单元测试和复杂的功能测试
    3.支持参数化
    4.执行测试过程中可以将某些测试跳过，或者对某些预期失败的Case标记成失败
    5.支持重复执行失败的Case
    6.支持运行由Nose , Unittest编写的测试Case
    7.具有很多第三方插件，并且可以自定义扩展
    8.方便的和持续集成工具集成
</code></pre>

<h3 id="toc_108">Pytest安装</h3>

<pre><code>    1.mac／linux：sudo pip3 install -U pytest # -U:可以理解为--upgrade，表示已安装就升级为最新版本
    2.管理员方式运行cmd：pip3 install -U pytest
</code></pre>

<h3 id="toc_109">Pytest安装成功校验</h3>

<pre><code>    1.进入命令行
    2.运行：pytest --version # 会展示当前已安装版本
</code></pre>

<h2 id="toc_110">15.Pytest基本使用</h2>

<h3 id="toc_111">Hello Pytest</h3>

<pre><code>    # file_name: test_abc.py
    import pytest # 引入pytest包
    def test_a(): # test开头的测试函数
        print(&quot;-------&gt;test_a&quot;)
        assert 1 # 断言成功
    def test_b():
        print(&quot;-------&gt;test_b&quot;)
        assert 0 # 断言失败
    if __name__ == &#39;__main__&#39;:
        pytest.main(&quot;-s  test_abc.py&quot;) # 调用pytest的main函数执行测试

</code></pre>

<pre><code>    执行结果：
        test_abc.py 
        -------&gt;test_a
        . # .(代表成功)
        -------&gt;test_b
        F # F(代表失败)
</code></pre>

<h3 id="toc_112">Pytest运行方式</h3>

<ul>
<li>1.测试类主函数模式</li>
</ul>

<pre><code>    pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>

<ul>
<li>2.命令行模式</li>
</ul>

<pre><code>    pytest 文件路径／测试文件名
    例如：
        pytest ./test_abc.py
</code></pre>

<h2 id="toc_113">16.setup和teardown函数</h2>

<ul>
<li>概述
<code>
1.setup和teardown主要分为：函数级、类级、模块级、功能级。
2.存在于测试类内部
</code>
### 函数级别</li>
</ul>

<pre><code>    运行于测试方法的始末，即:运行一次测试函数会运行一次setup和teardown
</code></pre>

<pre><code>    代码示例：
        import pytest
        class TestABC:
            # 函数级开始
            def setup(self):
                print(&quot;-------&gt;setup_method&quot;)
            # 函数级结束
            def teardown(self):
                print(&quot;-------&gt;teardown_method&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
            def test_b(self):
                print(&quot;-------&gt;test_b&quot;)
        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>

<pre><code>    执行结果：
        test_abc.py 
        -------&gt;setup_method # 第一次 setup()
        -------&gt;test_a
        .
        -------&gt;teardown_method # 第一次 teardown()
        -------&gt;setup_method # 第二次 setup()
        -------&gt;test_b
        .
        -------&gt;teardown_method # 第二次 teardown()
</code></pre>

<h3 id="toc_114">类级别</h3>

<pre><code>    运行于测试类的始末，即:在一个测试内只运行一次setup_class和teardown_class，不关心测试类内有多少个测试函数。
</code></pre>

<pre><code>    代码示例：
        import pytest
        class TestABC:
            # 测试类级开始
            def setup_class(self):
                print(&quot;-------&gt;setup_class&quot;)
            # 测试类级结束
            def teardown_class(self):
                print(&quot;-------&gt;teardown_class&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
            def test_b(self):
                print(&quot;-------&gt;test_b&quot;)
        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>

<pre><code>    执行结果：
        test_abc.py 
        -------&gt;setup_class # 第一次 setup_class()
        -------&gt;test_a
        .
        -------&gt;test_b
        F 
        -------&gt;teardown_class # 第一次 teardown_class()
</code></pre>

<h2 id="toc_115">17.Pytest配置文件</h2>

<pre><code>    pytest的配置文件通常放在测试目录下，名称为pytest.ini，命令行运行时会使用该配置文件中的配置.
</code></pre>

<h3 id="toc_116">配置pytest命令行运行参数</h3>

<pre><code>    [pytest]
    addopts = -s ... # 空格分隔，可添加多个命令行参数 -所有参数均为插件包的参数
</code></pre>

<h3 id="toc_117">配置测试搜索的路径</h3>

<pre><code>    [pytest]
    testpaths = ./scripts  # 当前目录下的scripts文件夹 -可自定义
</code></pre>

<h3 id="toc_118">配置测试搜索的文件名</h3>

<pre><code>    [pytest]
    python_files = test_*.py  
    # 当前目录下的scripts文件夹下，以test_开头，以.py结尾的所有文件 -可自定义
</code></pre>

<h3 id="toc_119">配置测试搜索的测试类名</h3>

<pre><code>    [pytest]
    python_classes = Test*  
    # 当前目录下的scripts文件夹下，以test_开头，以.py结尾的所有文件中，以Test_开头的类 -可自定义
</code></pre>

<h3 id="toc_120">配置测试搜索的测试函数名</h3>

<pre><code>    [pytest]
    python_functions = test_*  
    # 当前目录下的scripts文件夹下，以test_开头，以.py结尾的所有文件中，以Test_开头的类内，以test_开头的方法 -可自定义
</code></pre>

<h2 id="toc_121">18.Pytest常用插件</h2>

<pre><code>    插件列表网址：https://plugincompat.herokuapp.com
    包含很多插件包，大家可依据工作的需求选择使用。
</code></pre>

<pre><code>    前置条件：
        1.文件路径：
            - Test_App
            - - test_abc.py
            - - pytest.ini
        2.pyetst.ini配置文件内容：
            [pytest]
            # 命令行参数
            addopts = -s
            # 搜索文件名
            python_files = test_*.py
            # 搜索的类名
            python_classes = Test*
            # 搜索的函数名
            python_functions = test_*
</code></pre>

<h3 id="toc_122">Pytest测试报告</h3>

<pre><code>    通过命令行方式，生成xml/html格式的测试报告，存储于用户指定路径。
</code></pre>

<pre><code>    插件名称：pytest-html
    安装方式：
        1.安装包方式 python setup.py install 
        2.命令行 pip3 install pytest-html
    使用方法：
        命令行格式：pytest --html=用户路径/report.html
</code></pre>

<pre><code>    示例：
        import pytest
        class TestABC:
            def setup_class(self):
                print(&quot;-------&gt;setup_class&quot;)
            def teardown_class(self):
                print(&quot;-------&gt;teardown_class&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
            def test_b(self):
                print(&quot;-------&gt;test_b&quot;)
                assert 0 # 断言失败
    运行方式：
        1.修改Test_App/pytest.ini文件，添加报告参数，即：addopts = -s --html=./report.html 
            # -s:输出程序运行信息
            # --html=./report.html 在当前目录下生成report.html文件
            ⚠️ 若要生成xml文件，可将--html=./report.html 改成 --html=./report.xml
        2.命令行进入Test_App目录
        3.执行命令： pytest
    执行结果：
        1.在当前目录会生成assets文件夹和report.html文件
</code></pre>

<p><img src="./%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95_image/report.png" alt="报告截图"/></p>

<h3 id="toc_123">Pytest控制函数执行顺序</h3>

<pre><code>    函数修饰符的方式标记被测试函数执行的顺序.
</code></pre>

<pre><code>    插件名称：pytest-ordering
    安装方式：
        1.安装包方式 python setup.py install 
        2.命令行 pip3 install pytest-ordering
    使用方法：
        1.标记于被测试函数，@pytest.mark.run(order=x)
        2.根据order传入的参数来解决运行顺序
        3.order值全为正数或全为负数时，运行顺序：值越小，优先级越高
        4.正数和负数同时存在：正数优先级高
</code></pre>

<pre><code>    默认情况下，pytest是根据测试方法名由小到大执行的,可以通过第三方插件包改变其运行顺序。
</code></pre>

<pre><code>    默认执行方式
    示例：
        import pytest
        class TestABC:
            def setup_class(self):
                print(&quot;-------&gt;setup_class&quot;)
            def teardown_class(self):
                print(&quot;-------&gt;teardown_class&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
            def test_b(self):
                print(&quot;-------&gt;test_b&quot;)
                assert 0
        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
    执行结果：
        test_abc.py 
        -------&gt;setup_class
        -------&gt;test_a # 默认第一个运行
        .
        -------&gt;test_b # 默认第二个运行
        F
        -------&gt;teardown_class
</code></pre>

<pre><code>    示例：
        import pytest
        class TestABC:
            def setup_class(self):
                print(&quot;-------&gt;setup_class&quot;)

            def teardown_class(self):
                print(&quot;-------&gt;teardown_class&quot;)
            @pytest.mark.run(order=2)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1

            @pytest.mark.run(order=1)
            def test_b(self):
                print(&quot;-------&gt;test_b&quot;)
                assert 0
        if __name__ == &#39;__main__&#39;:
                pytest.main(&quot;-s  test_abc.py&quot;)
    执行结果：
        test_abc.py
        -------&gt;setup_class
        -------&gt;test_b # order=1 优先运行
        F
        -------&gt;test_a # order=2 晚于 order=1 运行
        .
        -------&gt;teardown_class

</code></pre>

<h3 id="toc_124">Pytest失败重试</h3>

<pre><code>    通过命令行方式，控制失败函数的重试次数。
</code></pre>

<pre><code>    插件名称：pytest-rerunfailures
    安装方式：
        1.安装包方式 python setup.py install 
        2.命令行 pip3 install pytest-rerunfailures
    使用方法：
        命令行格式：pytest --reruns n # n：为重试的次数
</code></pre>

<pre><code>    示例：
    import pytest
    class Test_ABC:
        def setup_class(self):
            print(&quot;-------&gt;setup_class&quot;)
        def teardown_class(self):
            print(&quot;-------&gt;teardown_class&quot;)
        def test_a(self):
            print(&quot;-------&gt;test_a&quot;)
            assert 1
        def test_b(self):
            print(&quot;-------&gt;test_b&quot;)
            assert 0 # 断言失败
    运行方式：
        1.修改Test_App/pytest.ini文件，添加失败重试参数，即：addopts = -s  --reruns 2 --html=./report.html 
            # -s:输出程序运行信息
            # --reruns 2 ：失败测试函数重试两次
            # --html=./report.html 在当前目录下生成report.html文件
        2.命令行进入Test_App目录
        3.执行命令： pytest
    执行结果：
        1.在测试报告中可以看到两次重试记录
</code></pre>

<p><img src="../m_image/%E9%87%8D%E8%AF%95.png" alt="失败重试"/></p>

<h2 id="toc_125">19.Pytest-fixture</h2>

<pre><code>    fixture修饰器来标记固定的工厂函数,在其他函数，模块，类或整个工程调用它时会被激活并优先执行,
        通常会被用于完成预置处理和重复操作。
</code></pre>

<pre><code>    方法：fixture(scope=&quot;function&quot;, params=None, autouse=False, ids=None, name=None)
    常用参数:
        scope：被标记方法的作用域
            function&quot; (default)：作用于每个测试方法，每个test都运行一次
            &quot;class&quot;：作用于整个类，每个class的所有test只运行一次
            &quot;module&quot;：作用于整个模块，每个module的所有test只运行一次
            &quot;session：作用于整个session(慎用)，每个session只运行一次
        params：(list类型)提供参数数据，供调用标记方法的函数使用
        autouse：是否自动运行,默认为False不运行，设置为True自动运行
</code></pre>

<h3 id="toc_126">fixture(通过参数引用)</h3>

<pre><code>    示例：
        import pytest
        class TestABC:
            @pytest.fixture()
            def before(self):
                print(&quot;-------&gt;before&quot;)
            def test_a(self,before): # ⚠️ test_a方法传入了被fixture标识的函数，已变量的形式
                print(&quot;-------&gt;test_a&quot;)
                assert 1
        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>

<pre><code>    执行结果：
        test_abc.py 
        -------&gt;before # 发现before会优先于测试函数运行
        -------&gt;test_a
        .  
</code></pre>

<h3 id="toc_127">fixture(通过函数引用)</h3>

<pre><code>    示例：
        import pytest
        @pytest.fixture() # fixture标记的函数可以应用于测试类外部
        def before():
            print(&quot;-------&gt;before&quot;)
        @pytest.mark.usefixtures(&quot;before&quot;)
        class TestABC:
            def setup(self):
                print(&quot;-------&gt;setup&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>

<pre><code>    执行结果：
        test_abc.py 
        -------&gt;before # 发现before会优先于测试类运行
        -------&gt;setup
        -------&gt;test_a
        .
</code></pre>

<h3 id="toc_128">fixture(默认设置为运行)</h3>

<pre><code>    示例：
        import pytest
        @pytest.fixture(autouse=True) # 设置为默认运行
        def before():
            print(&quot;-------&gt;before&quot;)
        class TestABC:
            def setup(self):
                print(&quot;-------&gt;setup&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>

<pre><code>    执行结果：
        test_abc.py 
        -------&gt;before # 发现before自动优先于测试类运行
        -------&gt;setup
        -------&gt;test_a
        .
</code></pre>

<h3 id="toc_129">fixture(作用域为function)</h3>

<pre><code>    示例：
        import pytest
        @pytest.fixture(scope=&#39;function&#39;,autouse=True) # 作用域设置为function，自动运行
        def before():
            print(&quot;-------&gt;before&quot;)
        class TestABC:
            def setup(self):
                print(&quot;-------&gt;setup&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
            def test_b(self):
                print(&quot;-------&gt;test_b&quot;)
                assert 1
        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>

<pre><code>    执行结果：
        test_abc.py
        -------&gt;before # 运行第一次
        -------&gt;setup
        -------&gt;test_a
        .-------&gt;before # 运行第二次
        -------&gt;setup
        -------&gt;test_b
        .
</code></pre>

<h3 id="toc_130">fixture(作用域为class)</h3>

<pre><code>    示例：
        import pytest
        @pytest.fixture(scope=&#39;class&#39;,autouse=True) # 作用域设置为class，自动运行
        def before():
            print(&quot;-------&gt;before&quot;)
        class TestABC:
            def setup(self):
                print(&quot;-------&gt;setup&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
            def test_b(self):
                print(&quot;-------&gt;test_b&quot;)
                assert 1
        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
</code></pre>

<pre><code>    执行结果：
        test_abc.py
        -------&gt;before # 发现只运行一次
        -------&gt;setup
        -------&gt;test_a
        .
        -------&gt;setup
        -------&gt;test_b
        .
</code></pre>

<h3 id="toc_131">fixture(返回值)</h3>

<pre><code>    示例一:
        import pytest
        @pytest.fixture()
        def need_data():
            return 2 # 返回数字2

        class TestABC:
            def test_a(self,need_data):
                print(&quot;-------&gt;test_a&quot;)
                assert need_data != 3 # 拿到返回值做一次断言

        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
    执行结果：
        test_abc.py 
        -------&gt;test_a
        .  
</code></pre>

<pre><code>    示例二:
        import pytest
        @pytest.fixture(params=[1, 2, 3])
        def need_data(request): # 传入参数request 系统封装参数
            return request.param # 取列表中单个值，默认的取值方式

        class TestABC:

            def test_a(self,need_data):
                print(&quot;-------&gt;test_a&quot;)
                assert need_data != 3 # 断言need_data不等于3

        if __name__ == &#39;__main__&#39;:
            pytest.main(&quot;-s  test_abc.py&quot;)
    执行结果：
        # 可以发现结果运行了三次
        test_abc.py 
        1
        -------&gt;test_a
        .
        2
        -------&gt;test_a
        .
        3
        -------&gt;test_a
        F 
</code></pre>

<h2 id="toc_132">20.Pytest高阶用法</h2>

<h3 id="toc_133">跳过测试函数</h3>

<pre><code>    根据特定的条件，不执行标识的测试函数.
</code></pre>

<pre><code>    方法：
        skipif(condition, reason=None)
    参数：
        condition：跳过的条件，必传参数
        reason：标注原因，必传参数
    使用方法：
        @pytest.mark.skipif(condition, reason=&quot;xxx&quot;)
</code></pre>

<pre><code>    示例：
        import pytest
        class TestABC:
            def setup_class(self):
                print(&quot;-------&gt;setup_class&quot;)
            def teardown_class(self):
                print(&quot;-------&gt;teardown_class&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
            @pytest.mark.skipif(condition=2&gt;1,reason = &quot;跳过该函数&quot;) # 跳过测试函数test_b
            def test_b(self):
                print(&quot;-------&gt;test_b&quot;)
                assert 0
    执行结果：
        test_abc.py 
        -------&gt;setup_class
        -------&gt;test_a #只执行了函数test_a
        .
        -------&gt;teardown_class
        s # 跳过函数
</code></pre>

<h3 id="toc_134">标记为预期失败函数</h3>

<pre><code>    标记测试函数为失败函数
</code></pre>

<pre><code>    方法：
        xfail(condition=None, reason=None, raises=None, run=True, strict=False)
    常用参数：
        condition：预期失败的条件，必传参数
        reason：失败的原因，必传参数
    使用方法：
        @pytest.mark.xfail(condition, reason=&quot;xx&quot;)
</code></pre>

<pre><code>    示例：
        import pytest
        class TestABC:
            def setup_class(self):
                print(&quot;-------&gt;setup_class&quot;)
            def teardown_class(self):
                print(&quot;-------&gt;teardown_class&quot;)
            def test_a(self):
                print(&quot;-------&gt;test_a&quot;)
                assert 1
            @pytest.mark.xfail(2 &gt; 1, reason=&quot;标注为预期失败&quot;) # 标记为预期失败函数test_b
            def test_b(self):
                print(&quot;-------&gt;test_b&quot;)
                assert 0
    执行结果：
        test_abc.py 
        -------&gt;setup_class
        -------&gt;test_a
        .
        -------&gt;test_b
        -------&gt;teardown_class
        x  # 失败标记
</code></pre>

<h3 id="toc_135">函数数据参数化</h3>

<pre><code>    方便测试函数对测试属于的获取。
</code></pre>

<pre><code>    方法：
        parametrize(argnames, argvalues, indirect=False, ids=None, scope=None)
    常用参数：
        argnames：参数名
        argvalues：参数对应值，类型必须为list
                    当参数为一个时格式：[value]
                    当参数个数大于一个时，格式为:[(param_value1,param_value2.....),(param_value1,param_value2.....)]
    使用方法:
        @pytest.mark.parametrize(argnames,argvalues)
        ⚠️ 参数值为N个，测试方法就会运行N次
</code></pre>

<pre><code>    单个参数示例：
        import pytest
        class TestABC:
            def setup_class(self):
                print(&quot;-------&gt;setup_class&quot;)
            def teardown_class(self):
                print(&quot;-------&gt;teardown_class&quot;)

            @pytest.mark.parametrize(&quot;a&quot;,[3,6]) # a参数被赋予两个值，函数会运行两遍
            def test_a(self,a): # 参数必须和parametrize里面的参数一致
                print(&quot;test data:a=%d&quot;%a)
                assert a%3 == 0
    执行结果:
        test_abc.py 
        -------&gt;setup_class
        test data:a=3 # 运行第一次取值a=3
        .
        test data:a=6 # 运行第二次取值a=6
        . 
        -------&gt;teardown_class
</code></pre>

<pre><code>    多个参数示例：
        import pytest
        class TestABC:
            def setup_class(self):
                print(&quot;-------&gt;setup_class&quot;)
            def teardown_class(self):
                print(&quot;-------&gt;teardown_class&quot;)

            @pytest.mark.parametrize(&quot;a,b&quot;,[(1,2),(0,3)]) # 参数a,b均被赋予两个值，函数会运行两遍
            def test_a(self,a,b): # 参数必须和parametrize里面的参数一致
                print(&quot;test data:a=%d,b=%d&quot;%(a,b))
                assert a+b == 3
    执行结果：
        test_abc.py 
        -------&gt;setup_class
        test data:a=1,b=2 # 运行第一次取值 a=1,b=2
        .
        test data:a=0,b=3 # 运行第二次取值 a=0,b=3
        .
        -------&gt;teardown_class
</code></pre>

<pre><code>    函数返回值类型示例：
        import pytest
        def return_test_data():
            return [(1,2),(0,3)]
        class TestABC:
            def setup_class(self):
                print(&quot;-------&gt;setup_class&quot;)
            def teardown_class(self):
                print(&quot;-------&gt;teardown_class&quot;)

            @pytest.mark.parametrize(&quot;a,b&quot;,return_test_data()) # 使用函数返回值的形式传入参数值
            def test_a(self,a,b):
                print(&quot;test data:a=%d,b=%d&quot;%(a,b))
                assert a+b == 3
    执行结果：
        test_abc.py 
        -------&gt;setup_class
        test data:a=1,b=2 # 运行第一次取值 a=1,b=2
        .
        test data:a=0,b=3 # 运行第二次取值 a=0,b=3
        .
        -------&gt;teardown_class
</code></pre>

<h2 id="toc_136">小作业</h2>

<h3 id="toc_137">元素定位和操作练习</h3>

<ul>
<li>点击搜索按钮</li>
<li>输入“无线”</li>
<li>获取当前有几条记录?</li>
</ul>

<h3 id="toc_138">滑动和拖拽时间练习</h3>

<ul>
<li>想办法滑动到最后的“关于手机”</li>
<li>点击进去</li>
<li>看当前页面是不是有一个“5.1”的字符串</li>
</ul>

<h2 id="toc_139">常用代码</h2>

<h3 id="toc_140">前置代码</h3>

<pre><code>    from appium import webdriver
    # server 启动参数
    desired_caps = {}
    # 设备信息
    desired_caps[&#39;platformName&#39;] = &#39;Android&#39;
    desired_caps[&#39;platformVersion&#39;] = &#39;5.1&#39;
    desired_caps[&#39;deviceName&#39;] = &#39;192.168.56.101:5555&#39;
    # app的信息
    desired_caps[&#39;appPackage&#39;] = &#39;com.android.settings&#39;
    desired_caps[&#39;appActivity&#39;] = &#39;.Settings&#39;
    # 解决输入中文
    desired_caps[&#39;unicodeKeyboard&#39;] = True
    desired_caps[&#39;resetKeyboard&#39;] = True

    # 声明我们的driver对象
    driver = webdriver.Remote(&#39;http://127.0.0.1:4723/wd/hub&#39;, desired_caps)
</code></pre>

<h3 id="toc_141">获取包名</h3>

<pre><code>1.Mac/Linux: &#39;adb shell dumpsys window windows | grep mFocusedApp’
2.在 Windows 终端运行 &#39;adb shell dumpsys window windows’ 然后去看mFocusedApp这一行的内容。
</code></pre>

<h3 id="toc_142">xPath</h3>

<pre><code>//*[contains(@,&#39;&#39;)]

</code></pre>

</div></body>

</html>
